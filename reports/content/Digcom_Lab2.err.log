Traceback (most recent call last):
  File "C:\Users\Sotiris\anaconda3\envs\digital_communications\lib\site-packages\jupyter_cache\executors\utils.py", line 58, in single_nb_execution
    executenb(
  File "C:\Users\Sotiris\anaconda3\envs\digital_communications\lib\site-packages\nbclient\client.py", line 1305, in execute
    return NotebookClient(nb=nb, resources=resources, km=km, **kwargs).execute()
  File "C:\Users\Sotiris\anaconda3\envs\digital_communications\lib\site-packages\jupyter_core\utils\__init__.py", line 173, in wrapped
    return loop.run_until_complete(inner)
  File "C:\Users\Sotiris\anaconda3\envs\digital_communications\lib\asyncio\base_events.py", line 616, in run_until_complete
    return future.result()
  File "C:\Users\Sotiris\anaconda3\envs\digital_communications\lib\site-packages\nbclient\client.py", line 705, in async_execute
    await self.async_execute_cell(
  File "C:\Users\Sotiris\anaconda3\envs\digital_communications\lib\site-packages\nbclient\client.py", line 1058, in async_execute_cell
    await self._check_raise_for_error(cell, cell_index, exec_reply)
  File "C:\Users\Sotiris\anaconda3\envs\digital_communications\lib\site-packages\nbclient\client.py", line 914, in _check_raise_for_error
    raise CellExecutionError.from_cell_and_msg(cell, exec_reply_content)
nbclient.exceptions.CellExecutionError: An error occurred while executing the following cell:
------------------
#6
with open('../files/sima.txt') as f:
    s = [float(x) for x in f]
s=np.array(s)
Fs=8192


# 7
f, Pxx = scipy.signal.welch(s, Fs)
#plt.figure(); plt.semilogy(f, Pxx); plt.grid(True); plt.xlabel('Frequency [Hz]'); plt.ylabel('PSD [V**2/Hz]')

# 8-9
N = Fs // 2  # Adjusted for Python indexing, assuming Fs is even
H = np.concatenate((np.ones(N//4), np.zeros(N//2), np.ones(N//4)))

# 10-14
h = np.fft.ifft(H, n=N).real
h = np.fft.fftshift(h)  # Equivalent to MATLAB's circshift for centering the impulse response

# 15-17
h32 = h[N//2-16:N//2+17]
h64 = h[N//2-32:N//2+33]
h128 = h[N//2-64:N//2+65]

# 18 - Stem plot for h32, h64, h128

# Create a 1x2 grid of subplots: one row, two columns
fig, axs = plt.subplots(1, 2, figsize=(14, 4))  # Adjust the figsize to suit your needs

# Plot stem plots on the left subplot (axs[0])
axs[0].stem(range(len(h64)), h64, basefmt=" ", linefmt='g-', markerfmt='go', label='h64')
axs[0].stem(range(len(h32)), h32, basefmt=" ", linefmt='b-', markerfmt='bo', label='h32')
axs[0].stem(range(len(h128)), h128, basefmt=" ", linefmt='r-', markerfmt='ro', label='h128')
axs[0].set_title('Stem Plot of h32, h64, h128')
axs[0].set_xlabel('Samples')
axs[0].set_ylabel('Amplitude')
axs[0].grid(True)
axs[0].legend()

# 19 - Frequency response of h64
w, h = scipy.signal.freqz(h64)
#plt.figure(); plt.plot(w / np.pi * (Fs / 2), np.abs(h)); plt.title('Frequency Response of h64');plt.xlabel('Frequency (Hz)');plt.ylabel('Magnitude');plt.grid()

# 20 - For visualizing the frequency responses of h32, h64, and h128 together
# Define a list of colors corresponding to each filter
colors = ['b', 'g', 'r']  # Blue for h32, Green for h64, Red for h128

for filt, label, color in zip([h32, h64, h128], ['h32', 'h64', 'h128'], colors):
    w, h = scipy.signal.freqz(filt)
    axs[1].plot(w / np.pi * (Fs / 2), 20 * np.log10(abs(h)), label=label, color=color)
axs[1].set_title('Frequency Responses of h32, h64, h128')
axs[1].set_xlabel('Frequency (Hz)')
axs[1].set_ylabel('Magnitude (dB)')
axs[1].grid(True)
axs[1].legend()

# Display the figure with plots side by side
plt.tight_layout()


# 22-26
wh = np.hamming(len(h64))
wk = np.kaiser_atten(len(h64), 5)
plt.figure(figsize=(14, 4)); plt.plot(wh, 'g', label='Hamming'); plt.plot(wk, 'r', label='Kaiser'); plt.legend(); plt.grid(True)

# 27-30
h_hamming = h64 * wh
h_kaiser = h64 * wk

# 31 `wvtool` equivalent visualization
# Plot the impulse responses
# Create a 1x2 grid of subplots
fig, axs = plt.subplots(1, 2, figsize=(14, 4))  # Adjust the figsize to suit your needs

# Impulse Responses Plot on the left subplot (axs[0])
axs[0].stem(range(len(h64)), h64, basefmt="b", linefmt='b-', markerfmt='bo', label='h64')
axs[0].stem(range(len(h_hamming)), h_hamming, basefmt="g", linefmt='g-', markerfmt='go', label='h_hamming')
axs[0].stem(range(len(h_kaiser)), h_kaiser, basefmt="r", linefmt='r-', markerfmt='ro', label='h_kaiser')
axs[0].set_title('Impulse Responses')
axs[0].set_xlabel('Samples')
axs[0].set_ylabel('Amplitude')
axs[0].legend()
axs[0].grid(True)

# Frequency Responses Plot on the right subplot (axs[1])
colors = ['b', 'g', 'r']  # Blue for h64, Green for h_hamming, Red for h_kaiser
for filt, label, color in zip([h64, h_hamming, h_kaiser], ['h64', 'h_hamming', 'h_kaiser'], colors):
    w, h = scipy.signal.freqz(filt)
    axs[1].plot(w / np.pi * (Fs / 2), 20 * np.log10(abs(h)), label=label, color=color)
axs[1].set_title('Frequency Responses')
axs[1].set_xlabel('Frequency (Hz)')
axs[1].set_ylabel('Magnitude (dB)')
axs[1].legend()
axs[1].grid(True)

plt.tight_layout()


# 32-38 Filtering and plotting PSD
y_rect = np.convolve(s, h64, mode='same')
f, Pxx = scipy.signal.welch(y_rect, Fs)
#plt.figure();plt.grid(True); plt.semilogy(f, Pxx); plt.xlabel('Frequency [Hz]'); plt.ylabel('PSD [V**2/Hz]'); plt.title('h64')

fig, axs = plt.subplots(1, 3, figsize=(14, 4))  # Adjust the figsize to suit your needs

axs[0].semilogy(f, Pxx); axs[0].grid(True); axs[0].set_xlabel('Frequency [Hz]'); axs[0].set_ylabel('PSD [V**2/Hz]')

y_hamm = np.convolve(s, h_hamming, mode='same')
f, Pxx = scipy.signal.welch(y_hamm, Fs)
#plt.figure();plt.grid(True); plt.semilogy(f, Pxx); plt.xlabel('Frequency [Hz]'); plt.ylabel('PSD [V**2/Hz]'); plt.title('h_hamming')

y_kais = np.convolve(s, h_kaiser, mode='same')
f, Pxx = scipy.signal.welch(y_kais, Fs)
axs[1].grid(True); axs[1].semilogy(f, Pxx); axs[1].set_xlabel('Frequency [Hz]'); axs[1].set_ylabel('PSD [V**2/Hz]'); axs[1].set_title('h_kaiser')

# 40-44  Parks-McClellan low-pass filter
freq = np.array([0, 0.10, 0.15, 0.5]) * Fs  # Scale frequencies correctly
gain = [1, 1, 0, 0]

# Call firwin2 with corrected parameters and using the `fs` parameter
hpm = scipy.signal.firwin2(65, freq, gain, fs=Fs)
s_pm = np.convolve(s, hpm, 'same')

# Plotting or analyzing the filtered signals (y_rect, y_hamm, y_kais, s_pm) can be done similarly
# For example, to plot the PSD:
f, Pxx_spec = scipy.signal.welch(s_pm, Fs, 'flattop', 1024, scaling='spectrum')
axs[2].semilogy(f, np.sqrt(Pxx_spec))
axs[2].set_xlabel('frequency [Hz]')
axs[2].grid(True)
axs[2].set_ylabel('Linear spectrum [V RMS]')
axs[2].set_title('Power spectrum (welch)')

plt.tight_layout()


# 45-46 Playing sound (s and s_pm assumed as original and filtered signal)
#sd.play(20 * s, Fs); sd.wait()
# sd.play(20 * s_lp, Fs); sd.wait()  # Uncomment and adjust variable name as needed for the filtered signal
------------------


[1;31m---------------------------------------------------------------------------[0m
[1;31mAttributeError[0m                            Traceback (most recent call last)
Cell [1;32mIn[4], line 63[0m
[0;32m     61[0m [38;5;66;03m# 22-26[39;00m
[0;32m     62[0m wh [38;5;241m=[39m np[38;5;241m.[39mhamming([38;5;28mlen[39m(h64))
[1;32m---> 63[0m wk [38;5;241m=[39m [43mnp[49m[38;5;241;43m.[39;49m[43mkaiser_atten[49m([38;5;28mlen[39m(h64), [38;5;241m5[39m)
[0;32m     64[0m plt[38;5;241m.[39mfigure(figsize[38;5;241m=[39m([38;5;241m14[39m, [38;5;241m4[39m)); plt[38;5;241m.[39mplot(wh, [38;5;124m'[39m[38;5;124mg[39m[38;5;124m'[39m, label[38;5;241m=[39m[38;5;124m'[39m[38;5;124mHamming[39m[38;5;124m'[39m); plt[38;5;241m.[39mplot(wk, [38;5;124m'[39m[38;5;124mr[39m[38;5;124m'[39m, label[38;5;241m=[39m[38;5;124m'[39m[38;5;124mKaiser[39m[38;5;124m'[39m); plt[38;5;241m.[39mlegend(); plt[38;5;241m.[39mgrid([38;5;28;01mTrue[39;00m)
[0;32m     66[0m [38;5;66;03m# 27-30[39;00m

File [1;32m~\anaconda3\envs\digital_communications\lib\site-packages\numpy\__init__.py:320[0m, in [0;36m__getattr__[1;34m(attr)[0m
[0;32m    317[0m     [38;5;28;01mfrom[39;00m [38;5;21;01m.[39;00m[38;5;21;01mtesting[39;00m [38;5;28;01mimport[39;00m Tester
[0;32m    318[0m     [38;5;28;01mreturn[39;00m Tester
[1;32m--> 320[0m [38;5;28;01mraise[39;00m [38;5;167;01mAttributeError[39;00m([38;5;124m"[39m[38;5;124mmodule [39m[38;5;132;01m{!r}[39;00m[38;5;124m has no attribute [39m[38;5;124m"[39m
[0;32m    321[0m                      [38;5;124m"[39m[38;5;132;01m{!r}[39;00m[38;5;124m"[39m[38;5;241m.[39mformat([38;5;18m__name__[39m, attr))

[1;31mAttributeError[0m: module 'numpy' has no attribute 'kaiser_atten'

