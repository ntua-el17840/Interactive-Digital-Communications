Traceback (most recent call last):
  File "C:\Users\Sotiris\anaconda3\envs\digital_communications\lib\site-packages\jupyter_cache\executors\utils.py", line 58, in single_nb_execution
    executenb(
  File "C:\Users\Sotiris\anaconda3\envs\digital_communications\lib\site-packages\nbclient\client.py", line 1305, in execute
    return NotebookClient(nb=nb, resources=resources, km=km, **kwargs).execute()
  File "C:\Users\Sotiris\anaconda3\envs\digital_communications\lib\site-packages\jupyter_core\utils\__init__.py", line 173, in wrapped
    return loop.run_until_complete(inner)
  File "C:\Users\Sotiris\anaconda3\envs\digital_communications\lib\asyncio\base_events.py", line 616, in run_until_complete
    return future.result()
  File "C:\Users\Sotiris\anaconda3\envs\digital_communications\lib\site-packages\nbclient\client.py", line 705, in async_execute
    await self.async_execute_cell(
  File "C:\Users\Sotiris\anaconda3\envs\digital_communications\lib\site-packages\nbclient\client.py", line 1058, in async_execute_cell
    await self._check_raise_for_error(cell, cell_index, exec_reply)
  File "C:\Users\Sotiris\anaconda3\envs\digital_communications\lib\site-packages\nbclient\client.py", line 914, in _check_raise_for_error
    raise CellExecutionError.from_cell_and_msg(cell, exec_reply_content)
nbclient.exceptions.CellExecutionError: An error occurred while executing the following cell:
------------------
# The function grayCode accepts a number n and returns an array g containing
# the Gray coding for numbers with n bits.
# This is done by recursively calling the function gray_code_recurse
def grayCode(n):
    def gray_code_recurse (g,n):
        k=len(g)
        if n<=0:
            return
        else:
            for i in range (k-1,-1,-1):
                char='1'+g[i]
                g.append(char)
            for i in range (k-1,-1,-1):
                g[i]='0'+g[i]

            gray_code_recurse (g,n-1)

    g=['0','1']
    gray_code_recurse(g,n-1)
    return g


# The function naturalBinaryCoding accepts a number n and returns an array
# with binary numbers with n bits (or equivalently up to the number 2**n, which results
# by left shifting 1 by n bits)
def naturalBinaryCoding(n):
    binary_levels = []
    for i in range(1 << n):
        binary_levels.append('{:0{}b}'.format(i, n))
    return binary_levels


# The function generateRandomBits generates n_bits random binary digits
def generateRandomBits(n_bits):
    bitstream = []
    for i in range(n_bits):
        random_bit = random.randint(0, 1)
        bitstream.append(random_bit)
    return bitstream


# The function createLevels divides the range [-A, A] into L-1 equal intervals,
# so that it always contains the endpoints of the range
def createLevels(A, L):
    y = []
    step = (A - (-A)) / (L - 1)
    for i in range(L):
        y.append(-A + i * step)
    return y


# The function createSymbols takes an array with bits as an argument and
# groups neighboring digits into symbols with length k
def createSymbols(k, bitstream):
    n_bits = len(bitstream)
    symbols = []
    for i in range(0, n_bits - k + 1, k):
        symbol = ""
        for j in range(k):
            symbol += str(bitstream[i+j])
        symbols.append(symbol)
    return symbols


# The function rootRaisedCosine creates a root raised cosine pulse
# with a roll-off coefficient and order determined by the sampling rate (nsample)
# and the delay it will introduce (delay)
def rootRaisedCosine(nsamp, roll_off, delay):
    F0 = 0.5 / nsamp
    Fd = 1
    Fs = Fd * nsamp
    Td = 1 / Fd
    Ts = 1 / Fs
    F1 = F0 * (1 - roll_off)
    F2 = F0 * (1 + roll_off)
    filter_order = 2 * nsamp * delay

    t = np.arange(0, filter_order, Td)
    h = []
    for i in range(len(t)):
        t_shifted = t[i] - filter_order / 2
        if t_shifted == 0:
            h.append(np.sqrt(2 * F0) *(1 + roll_off * ((4 / np.pi) - 1)))
        elif t_shifted == 1 / 8 / roll_off / F0 or t_shifted == - 1 / 8 / roll_off / F0 :
            h.append((roll_off * np.sqrt(F0)) * ((1 + 2 / np.pi) * np.sin(np.pi / 4 / roll_off) + (1 - 2 / np.pi) * np.cos(np.pi / 4 / roll_off)))
        else:
            factor1 = np.sqrt(2 * F0) / (1 - 64 * roll_off* roll_off * F0 * F0 * t_shifted * t_shifted)
            factor2 = np.sin(2 * np.pi * F1 * t_shifted) / (2 * np.pi * F0 * t_shifted)
            factor3 = (4 * roll_off / np.pi) * np.cos(2 * np.pi * F2 * t_shifted) 
            h.append(factor1 * (factor2 + factor3))
    
    return t,h


# The function upSample increases the number of samples of a signal signal by adding nsamp-1
# zeros after each sample of the signal
def upSample(signal, nsamp):
    upSampled = []
    for i in range(len(signal) * nsamp):
        if i % nsamp == 0:
            upSampled.append(signal[i // nsamp])
        else:
            upSampled.append(0)
    return upSampled


# The function downSample reduces the sampling frequency of a signal signal by a factor of nsamp
# by keeping only the samples that are multiples of nsamp (0, nsamp, 2*nsamp, ...)
def downSample(signal, nsamp):
    downSampled = []
    for i in range(0, len(signal), nsamp):
        downSampled.append(signal[i])
        
    return downSampled


# Adds white Gaussian noise with mean value μ (mu) and variance σ^2 (sigma)
def generateAWGN(signal, mu, sigma):
    noise = sigma * np.random.randn(len(signal)) + mu
    return noise


# Loading animation
loading = """
    <div style='display: flex; justify-content: center; align-items: center; height: 80px;'>
        <div class='loader' style='border: 12px solid #f3f3f3; /* Light grey */
                                     border-top: 12px solid #01cc97; /* Blue */
                                     border-radius: 50%;
                                     width: 40px;
                                     height: 40px;
                                     animation: spin 2s linear infinite;'></div>
    </div>
    <style>
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    </style>
    """
done = """
        <div style='display: flex; justify-content: center; align-items: center; height: 80px;'>
            <div style='font-size: 40px; color: #01cc97;'>&#10003;</div>
        </div>
        """
loader_html1 = widgets.HTML(
  value=loading
)
timer_html1 = widgets.HTML(
    value="Elapsed time: - seconds"
)

# Output widget for dynamic updates
output = Output()

global filt, g_delay, g_nsamp
def interactive_signal_processing1(n_bits, L, roll_off, nsamp, delay):
    # Start timer
    loader_html1.value = loading
    start_time = time.time()

    global filt, g_delay, g_nsamp
    g_delay = delay
    g_nsamp = nsamp
    bitstream = generateRandomBits(n_bits)
    A = L - 1
    k = int(log2(L))
    y_levels = createLevels(A, L)
    symbols = createSymbols(k, bitstream)
    gray_encoding = grayCode(k)

    x_gray = [y_levels[gray_encoding.index(symbol)] for symbol in symbols]
    t_filter, filt = rootRaisedCosine(nsamp, roll_off, delay)
    y = upSample(x_gray, nsamp)
    y_transmitted = scipy.signal.convolve(y, filt)
    y_received = scipy.signal.convolve(y_transmitted, filt)
    y_final = downSample(y_received, nsamp)
    y_final = y_final[2 * delay: len(y_final) - 2 * delay]
    with output:
        output.clear_output(wait=True)  # Clear previous output
        fig = plt.figure(figsize=(20, 12))  # Create a figure object

        # First subplot - Root Raised Cosine Filter
        ax1 = fig.add_subplot(2, 2, 1)  # First plot in the first row, first column
        ax1.plot(t_filter, filt)
        ax1.set_title('Root Raised Cosine Filter')
        ax1.set_xlabel('Time')
        ax1.set_ylabel('Amplitude')
        ax1.grid(True)

        # Second subplot - Continuous signal with stems
        ax2 = fig.add_subplot(2, 2, 2)  # Second plot in the first row, second column
        t_continuous = np.arange(0, len(y_transmitted[:10*nsamp]))  # Time vector for continuous signal
        ax2.plot(t_continuous, y_transmitted[:10*nsamp], label='Filtered Signal')

        # Generating stem positions for original symbols
        t_symbols = np.arange(0, 10*nsamp, nsamp)  # Stem positions every nsamp samples

        # Get the corresponding y-values from y_transmitted at the stem positions
        y_stems = y_transmitted[t_symbols]

        ax2.stem(t_symbols, y_stems, linefmt='C1-', markerfmt='C1o', basefmt=" ", label='Original Symbols')

        ax2.set_title('Signal Visualization')
        ax2.set_xlabel('Time')
        ax2.set_ylabel('Amplitude')
        ax2.legend()
        ax2.grid(True)

        # Third subplot - Signal Visualization
        ax3 = fig.add_subplot(2, 2, 3)  # Third plot in the second row, first column
        t = np.arange(0, len(y[:10]))
        ax3.plot(t, y_final[:10])
        ax3.stem(t, x_gray[:10])
        ax3.set_title('Signal Visualization')
        ax3.legend(['Received','Transmittted'])
        ax3.set_xlabel('Time')
        ax3.set_ylabel('Amplitude')
        ax3.grid(True)

        # Fourth subplot - Power Spectral Density of the Received Signal
        ax4 = fig.add_subplot(2, 2, 4)  # Fourth plot in the second row, second column
        f, Pxx_den = scipy.signal.welch(y_received, window='hamming', nperseg=8192)
        Pxx_den = 10 * np.log10(Pxx_den)
        ax4.plot(f, Pxx_den)
        ax4.set_title('Power Spectral Density of the Received Signal')
        ax4.set_xlabel('Normalized Frequency')
        ax4.set_ylabel('Power/Frequency [dB]')
        ax4.grid(True)

        plt.tight_layout()  # Adjust the layout
            
        # Show elapsed time
        elapsed_time = time.time() - start_time
        timer_html1.value = f"Elapsed time: {elapsed_time:.2f} seconds"
        loader_html1.value = done
        
        plt.show()


# Widget setup
n_bits_slider1 = IntSlider(min=10000, max=100000, step=10000, value=10000, description='Bitstream Length', style={'description_width': 'initial'}, layout=Layout(width='100%'), continuous_update=False)
roll_off_slider1 = FloatSlider(min=0.1, max=1.0, step=0.1, value=0.4, description='Roll-off Factor', style={'description_width': 'initial'}, layout=Layout(width='100%'), continuous_update=False)
L_dropdown1 = Dropdown(options=[2**i for i in range(1, 6)], value=2, description='ASK Levels', style={'description_width': 'initial'}, continuous_update=False)
nsamp_slider1 = IntSlider(min=10, max=40, step=1, value=20, description='nsamp', style={'description_width': 'initial'}, layout=Layout(width='100%'), continuous_update=False)
delay_slider1 = IntSlider(min=1, max=10, step=1, value=5, description='Group Delay', style={'description_width': 'initial'}, layout=Layout(width='100%'), continuous_update=False)

w = interactive(interactive_signal_processing1, n_bits=n_bits_slider1, L=L_dropdown1, roll_off=roll_off_slider1, nsamp=nsamp_slider1, delay=delay_slider1)

def update_filter_order1(*args):
    filter_order1 = 2 * nsamp_slider1.value * delay_slider1.value
    filter_order_display1.value = filter_order1

# Observers
nsamp_slider1.observe(update_filter_order1, 'value')
delay_slider1.observe(update_filter_order1, 'value')

# Display filter order
filter_order_display1 = IntText(value=2 * nsamp_slider1.value * delay_slider1.value, description='Filter Order:', disabled=True)

inputs = widgets.VBox([n_bits_slider1, roll_off_slider1, nsamp_slider1, delay_slider1, filter_order_display1, L_dropdown1])

# Group the loader and timer together (they will appear next to each other horizontally)
loader_timer_box = widgets.VBox([loader_html1, timer_html1], layout=widgets.Layout(margin='0 0 0 20px', width='auto'))

ui = widgets.HBox([inputs, loader_timer_box], layout=Layout(align_items='center', flex_flow='row nowrap'))
inputs.layout.flex = '1 1 auto'  # Flex-grow, flex-shrink, flex-basis
loader_timer_box.layout.flex = '0 1 auto'  # No flex-grow, flex-shrink, fixed basis as needed

# Layout
display(ui, output)

# Initial update of filter order
update_filter_order()
------------------


[1;31m---------------------------------------------------------------------------[0m
[1;31mNameError[0m                                 Traceback (most recent call last)
Cell [1;32mIn[2], line 273[0m
[0;32m    270[0m display(ui, output)
[0;32m    272[0m [38;5;66;03m# Initial update of filter order[39;00m
[1;32m--> 273[0m [43mupdate_filter_order[49m()

[1;31mNameError[0m: name 'update_filter_order' is not defined

